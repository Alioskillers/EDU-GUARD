import { Injectable } from '@nestjs/common';
import { DatabaseService } from '../database/database.service';
import { CreateUserFromAuthDto } from './dto/create-user-from-auth.dto';
import { RequestUser } from '../common/interfaces/request-user.interface';

@Injectable()
export class UsersService {
  constructor(private readonly db: DatabaseService) {}

  private mapRowToRequestUser(row: any): RequestUser {
    const childProfile = row.child_id
      ? {
          id: row.child_id,
          display_name: row.display_name,
          age: row.age,
          age_group: row.age_group,
          avatar_url: row.avatar_url ?? null,
          guardian_code: row.guardian_code ?? undefined,
        }
      : null;

    // Log guardian_code for debugging (only for CHILD users)
    if (childProfile && row.role === 'CHILD') {
      console.log('Mapping child profile - guardian_code:', row.guardian_code, 'exists:', !!row.guardian_code);
    }

    return {
      id: row.id,
      auth_user_id: row.auth_user_id,
      email: row.email,
      full_name: row.full_name,
      role: row.role,
      child_profile: childProfile,
    };
  }

  async findByAuthUserId(authUserId: string): Promise<RequestUser | null> {
    const result = await this.db.query(
      `
      SELECT u.*, c.id as child_id, c.display_name, c.age, c.age_group, c.avatar_url, c.guardian_code
      FROM users u
      LEFT JOIN children c ON c.user_id = u.id
      WHERE u.auth_user_id = $1
    `,
      [authUserId],
    );

    if (result.rowCount === 0) {
      return null;
    }

    const user = result.rows[0];

    // Auto-create child profile for CHILD users if missing
    if (user.role === 'CHILD' && !user.child_id) {
      // Try to get age/age_group from user metadata (stored during sign-up)
      // This would need to be passed from the JWT validation, but for now use defaults
      const defaultAge = 6;
      const defaultAgeGroup = '6_8';
      const displayName = user.full_name || user.email?.split('@')[0] || 'Player';

      await this.db.query(
        `INSERT INTO children (user_id, display_name, age, age_group)
         VALUES ($1, $2, $3, $4)`,
        [user.id, displayName, defaultAge, defaultAgeGroup],
      );

      // Fetch again to include the newly created child profile
      const updatedUser = await this.findById(user.id);
      return updatedUser || this.mapRowToRequestUser(user);
    }

    return this.mapRowToRequestUser(user);
  }

  async findById(id: string): Promise<RequestUser | null> {
    const result = await this.db.query(
      `SELECT u.*, c.id as child_id, c.display_name, c.age, c.age_group, c.avatar_url, c.guardian_code
       FROM users u
       LEFT JOIN children c ON c.user_id = u.id
       WHERE u.id = $1`,
      [id],
    );

    return result.rowCount ? this.mapRowToRequestUser(result.rows[0]) : null;
  }

  async createFromAuthPayload(
    payload: CreateUserFromAuthDto,
  ): Promise<RequestUser> {
    const result = await this.db.query(
      `INSERT INTO users (auth_user_id, email, full_name, role)
       VALUES ($1, $2, $3, $4)
       RETURNING *`,
      [payload.auth_user_id, payload.email, payload.full_name, payload.role],
    );

    const user = result.rows[0];

    // Auto-create child profile for CHILD users if it doesn't exist
    if (payload.role === 'CHILD') {
      // Check if child profile already exists
      const existingChild = await this.db.query(
        `SELECT id FROM children WHERE user_id = $1`,
        [user.id],
      );

      if (existingChild.rowCount === 0) {
        // Use provided age/age_group from sign-up, or defaults
        const age = payload.age ? parseInt(String(payload.age), 10) : 6;
        const ageGroup = payload.age_group || '6_8';
        const displayName = payload.full_name || payload.email?.split('@')[0] || 'Player';

        // Insert child profile - guardian_code will be auto-generated by database trigger
        const childResult = await this.db.query(
          `INSERT INTO children (user_id, display_name, age, age_group)
           VALUES ($1, $2, $3, $4)
           RETURNING id, guardian_code`,
          [user.id, displayName, age, ageGroup],
        );
        console.log('Child profile created with guardian_code:', childResult.rows[0]?.guardian_code);
      }
    }

    // Fetch the user again to include the child profile if created
    const updatedUser = await this.findById(user.id);
    return updatedUser || this.mapRowToRequestUser(user);
  }

  async listChildrenForParent(parentId: string) {
    const result = await this.db.query(
      `SELECT c.*, g.relationship
       FROM guardianship g
       JOIN children c ON c.id = g.child_id
       WHERE g.parent_id = $1`,
      [parentId],
    );

    return result.rows;
  }

  // FR-07: Create child profile and link to parent
  async linkChildByGuardianCode(
    parentId: string,
    guardianCode: string,
    relationship: string,
  ) {
    const client = await this.db.getClient();
    
    try {
      await client.query('BEGIN');

      // Find child by guardian code
      const childResult = await client.query(
        `SELECT c.id, c.user_id FROM children c WHERE c.guardian_code = $1`,
        [guardianCode],
      );

      if (childResult.rowCount === 0) {
        throw new Error('Invalid guardian code. Please check the code and try again.');
      }

      const childId = childResult.rows[0].id;

      // Check if guardianship already exists
      const existingGuardianship = await client.query(
        `SELECT id FROM guardianship WHERE parent_id = $1 AND child_id = $2`,
        [parentId, childId],
      );

      if (existingGuardianship.rowCount > 0) {
        throw new Error('This child is already linked to your account.');
      }

      // Create guardianship link
      await client.query(
        `INSERT INTO guardianship (parent_id, child_id, relationship)
         VALUES ($1, $2, $3)`,
        [parentId, childId, relationship],
      );

      await client.query('COMMIT');

      return { success: true, child_id: childId, message: 'Child linked successfully using guardian code.' };
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  async createChildProfileForParent(
    parentId: string,
    email: string,
    displayName: string,
    age: number,
    ageGroup: string,
    relationship: string,
  ) {
    // NFR-11: Use transaction for data integrity
    const client = await this.db.getClient();
    
    try {
      await client.query('BEGIN');

      // Find or create user by email
      let userResult = await client.query(
        `SELECT id, role FROM users WHERE email = $1`,
        [email],
      );

      let userId: string;
      if (userResult.rowCount === 0) {
        // User doesn't exist - we can't create auth user from here
        // For now, we'll require the child to sign up first
        throw new Error('User with this email does not exist. Please have the child sign up first.');
      }

      userId = userResult.rows[0].id;

      // Check if child profile exists
      let childResult = await client.query(
        `SELECT id FROM children WHERE user_id = $1`,
        [userId],
      );

      let childId: string;
      if (childResult.rowCount === 0) {
        // Create child profile (guardian_code will be auto-generated by trigger)
        childResult = await client.query(
          `INSERT INTO children (user_id, display_name, age, age_group)
           VALUES ($1, $2, $3, $4)
           RETURNING id, guardian_code`,
          [userId, displayName, age, ageGroup],
        );
        childId = childResult.rows[0].id;
      } else {
        childId = childResult.rows[0].id;
      }

      // Create guardianship link if it doesn't exist
      await client.query(
        `INSERT INTO guardianship (parent_id, child_id, relationship)
         VALUES ($1, $2, $3)
         ON CONFLICT (parent_id, child_id) DO NOTHING`,
        [parentId, childId, relationship],
      );

      await client.query('COMMIT');

      return { success: true, child_id: childId };
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }
}
